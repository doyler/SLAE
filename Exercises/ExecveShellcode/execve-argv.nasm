; Filename: execve-argv.nasm
; Author: Ray Doyle
; Website: https://www.doyler.net
;
; Purpose: Execute `/bin/ls -al` via the JMP-CALL-POP technique

global _start

section .text
_start:
    jmp short call_program

program:
    ; JMP-CALL-POP to load the prog variable into ESI
    pop esi

    ; Clear EAX and push onto the stack (null terminator)
    xor eax, eax
    push eax

    ; Copy the program (in this case, /bin/ls) onto the top of the stack
    ; Note that this only works because I had enough space + null pointers already on the stack
    ; If this command was any longer, this program would have likely failed
    mov edi, esp
    mov cl, progLen
    rep movsb

    ; Move the stack pointer into EBX (null-terminated filename for execve)
    mov ebx, esp

    ; Push more null bytes and load them into EDX (envp - 0x00000000)
    push eax
    mov edx, esp

    jmp short call_args

args:
    ; JMP-CALL-POP to load the argv variable into ESI
    pop esi

    ; Copy the argments (in this case, -al) onto the top of the stack (null terminated)
    ; This works fine since '-al' is less than 4 bytes
    push eax
    mov edi, esp
    mov cl, argvLen
    rep movsb
    
    ; Move the stack pointer (pointing to the arguments structure) into ESI for later
    mov esi, esp

    ; Push the argument struct onto the stack in the proper order, and load into ECX
    push eax
    push esi
    push ebx
    mov ecx, esp

    ; Place 11 (sys_execve) into EAX and execute
    mov al,11
    int 0x80

call_program:
    call program
    prog: db "/bin/ls"
    progLen equ $-prog

call_args:
    call args
    argv: db "-al"
    argvLen equ $-argv